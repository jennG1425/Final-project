###############################################################
#
# Copyright 2017 Sandia Corporation. Under the terms of
# Contract DE-AC04-94AL85000 with Sandia Corporation, the
# U.S. Government retains certain rights in this software.
# This software is distributed under the BSD-3-Clause license.
#
##############################################################

import numpy as np
import matplotlib.pyplot as plt

from plasticitypreprocessor import PlasticityDataProcessor
from tbnn import NetworkStructure, TBNN, DataProcessor

"""
In this example, a Tensor Basis Neural Network (TBNN) is trained on the data from a finite element model of a
polycrystalline specimen, with each crystal using a J2 plasticity constitutive law.  The objective is to learn the
flow rule of the aggregate material.  More information on the theory can be found in 'Computational Inelasticity'
by Simo and Hughes.
The input file contains a full symmetric tensor description of the strain, stress, plastic strain,
   strain rate/increment, plastic strain rate/increment, of which only the stress is unused
The outputs are the flow rule governing the rate of change of plastic strain.

Data:
The mesh was generated by J. Ostien and contains 15 voxelated crystals, each with a different orientation.
Simulation inputs, execution, and post-processing to evaluate the stress/strain and plastic strain responses
were generated by R. Jones, J. Ostien, and J. Templeton.

References forthcoming.
"""


def load_plasticity_data():
    """
    Loads in plastic deformation strain, plastic strain, plastic strain time derivative, strain time derivative
    :return: strain: the total strain tensor
    :return: plastic_strain: the portion of the strain tensor which corresponds to plastic deformation
    :return: strain_dot: the increment or time derivative of total strain
    :return: plastric_strain_dot: the increment or time derivative of plastic strain
    """
    # Read in data file
    # column order is 6 entries per tensor:  (0, 0), (1, 1), (2, 2), (1, 2), (0, 2), (0, 1)
    data = np.loadtxt("plasticity_data.txt", skiprows=1)
    strain_flat = data[:, 0:6]
    plastic_strain_flat = data[:, 12:18]
    strain_dot_flat = data[:, 18:24]
    plastic_strain_dot_flat = data[:, 24:30]

    # Convert flat vectors to full tensors
    vector2tensor = [[0, 0], [1, 1], [2, 2], [1, 2], [0, 2], [0, 1]]
    num_points = strain_flat.shape[0]
    strain = np.zeros((num_points, 3, 3))
    plastic_strain = np.zeros((num_points, 3, 3))
    strain_dot = np.zeros((num_points, 3, 3))
    plastic_strain_dot = np.zeros((num_points, 3, 3))
    for i in range(0, 6):
        strain[:, vector2tensor[i][0], vector2tensor[i][1]] = strain_flat[:, i]
        strain[:, vector2tensor[i][1], vector2tensor[i][0]] = strain_flat[:, i]
        
        plastic_strain[:, vector2tensor[i][0], vector2tensor[i][1]] = plastic_strain_flat[:, i]
        plastic_strain[:, vector2tensor[i][1], vector2tensor[i][0]] = plastic_strain_flat[:, i]
        
        strain_dot[:, vector2tensor[i][0], vector2tensor[i][1]] = strain_dot_flat[:, i]
        strain_dot[:, vector2tensor[i][1], vector2tensor[i][0]] = strain_dot_flat[:, i]
        
        plastic_strain_dot[:, vector2tensor[i][0], vector2tensor[i][1]] = plastic_strain_dot_flat[:, i]
        plastic_strain_dot[:, vector2tensor[i][1], vector2tensor[i][0]] = plastic_strain_dot_flat[:, i]

    return strain, plastic_strain, strain_dot, plastic_strain_dot


def plot_results(predicted, true):
    """
    Create a plot with 9 subplots.  Each subplot shows the predicted vs the true value of the
    plastic strain time derivative tensor.
    Correct predictions should lie on the y=x line (shown with
    red dash).
    :param predicted: Predicted values
    :param true: True values
    """
    fig = plt.figure()
    fig.patch.set_facecolor('white')
    min_v = np.min(true)
    max_v = np.max(true)
    for i in xrange(9):
            plt.subplot(3, 3, i+1)
            ax = fig.gca()
            ax.set_aspect('equal')
            plt.plot([0., 1.], [0., 1.], 'r--')
            plt.scatter(true[:, i], predicted[:, i])
            plt.xlabel('True value')
            plt.ylabel('Predicted value')
            idx_1 = i / 3
            idx_2 = i % 3
            plt.title('Ep' + str(idx_1) + str(idx_2))
            plt.xlim([min_v, max_v*1.1])
            plt.ylim([min_v, max_v*1.1])
    plt.tight_layout()
    plt.show()


def main():
    # Define parameters:
    num_layers = 2  # Number of hidden layers in the TBNN
    num_nodes = 20  # Number of nodes per hidden layer
    max_epochs = 2000  # Max number of epochs during training
    min_epochs = 1000  # Min number of training epochs required
    interval = 100  # Frequency at which convergence is checked
    average_interval = 4  # Number of intervals averaged over for early stopping criteria
    learning_rate_decay = 0.995 # Reduction per epoch of the learning rate
    split_fraction = 0.8  # Fraction of data to use for training
    seed = 12345 # Random number generator seed for reproducibility, set equal to None for no seeding

    # Load in data
    strain, plastic_strain, strain_dot, plastic_strain_dot = load_plasticity_data()

    # Calculate inputs and outputs
    data_processor = PlasticityDataProcessor()
    x = data_processor.calc_scalar_basis(strain, plastic_strain, is_train=True)  # Scalar basis
    tb = data_processor.calc_tensor_basis(strain, plastic_strain)  # Tensor basis
    y = data_processor.calc_output(plastic_strain_dot, strain_dot)  # Plastic strain time derivative tensor

    # Split into training and test data sets
    if seed:
        np.random.seed(seed) # sets the random seed for Theano
    x_train, tb_train, y_train, x_test, tb_test, y_test = DataProcessor.train_test_split(x, tb, y,
                                                                                         fraction=split_fraction,
                                                                                         seed=seed)

    # Define network structure
    structure = NetworkStructure()
    structure.set_num_layers(num_layers)
    structure.set_num_nodes(num_nodes)

    # Initialize and fit TBNN
    tbnn = TBNN(structure, learning_rate_decay=learning_rate_decay)
    tbnn.fit(x_train, tb_train, y_train, max_epochs=max_epochs, min_epochs=min_epochs, interval=interval, average_interval=average_interval)

    # Make predictions on train and test data to get train error and test error
    labels_train = tbnn.predict(x_train, tb_train)
    labels_test = tbnn.predict(x_test, tb_test)

    # Determine error
    rmse_train = tbnn.rmse_score(y_train, labels_train)
    rmse_test = tbnn.rmse_score(y_test, labels_test)
    print "RMSE on training data:", rmse_train
    print "RMSE on test data:", rmse_test

    # Plot the results
    # Note: For this example problem, the only non-zero component should be the 00 component
    plot_results(labels_test, y_test)


if __name__ == "__main__":
    main()
